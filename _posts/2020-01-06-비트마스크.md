---
date: 2020-01-06 00:35:03
layout: post
title: "비트마스크"
subtitle:
description:
image:
optimized_image:
category:
tags:
author:
paginate: false
---

#비트마스크
비트마스크 : 정수의 이진수 표현을 자료구조로 쓰는 기법

####장점
    1. 더 빠른 수행시간
    2. 더 간결한 코드
    3. 더 작은 메모리 사용량
    4. 연관 배열을 배열로 대체
    
####유의할점(1)
연산자간 우선순위의 혼동
```C
    int c = (6 & 4 == 4);
    int d = ((6&4) == 4);
```
C++이나 JAVA 같은 경우 &,|,^등의 비트 연산자의 우선 순위는 == 혹은 !=등의 비교 연산자보다 낮다.
그래서 연산자와 비교 연산자가 섞여 있는 경우 가능한 괄호를 자세하게 추가해야 한다!

####유의할점(2)
64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로
```C
    bool isBitSet(unsigned long long a, int b){
        return (a & (1 << b)) > 0;
    }
```
1. C++에서 1은 부호 있는 32비트 상수로 취급되기 때문에 b 가 32 이상일 경우 식(1<<b)에서 오버플로가 발생한다. 
이 문제를 해결하려면 1 뒤에 이 상수가 부호 없는 64비트 정수임을 알려주는 접미사 ull을 붙인다.
2. 부호 있는 정수형에서 최상위 비트는 부호를 나타내는 비트이다. 모든 비트를 사용해야 할 경우 자잘한 버그가 발생한다. 
예를 들어 음수를 오른쪽으로 시프트 할떄 왼쪽 끝 비트들이 0이 아니라 1로 채워질 수 있다. 이 문제를 해결하려면 부호 없는 정수형을 써야한다(모든 비트를 사용할 경우)

###비트마스크의 가장 중요한 사례 : 집합의 구현
피자집 예제) 0부터 19까지의 번호를 가지는 스무가지의 토핑이 있다. 토핑을 선택할 경우 1 이고 선택하지 않을 경우 0이다.
0. 공집합과 꽉찬 집합 구하기
    ```C
    int fullPizza = (1 << 20) - 1;
    ```
1. 원소추가
    ```C
    toppings |= (1 << p);  //p는 페퍼로니 토핑의 번
    ```
2. 포함 여부 확인
    ```C
    if(toppings & (1 << p)); //&의 연산 결과값은 1 또는 1<<p 이다(1또는true가 아니다!)
    ```
3. 원소 삭제
    ```C
    toppings -= (1 << p); //토핑목록에 있을경우
    toppings &= ~(1 << p); //토핑 목록에 있든 없든 
    ```
4. 원소의 토글
    ```C
    toppings ^= (1 << p);
    ```
5. 집합 연산
    ```C
    
    ```
6. 크기 구하기
    ```C
    
    ```
7. 켜진 최하위 비트 확인
    ```C
    
    ```
8. 최소 원소 지우기
    ```C
    
    ```

